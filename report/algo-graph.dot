digraph G {
layout="dot";
// 首先生成输入数据
  i_b_0[label="b,1"];
  i_a_1[label="a,2"];
  i_a_2[label="a,3"];
  i_b_3[label="b,4"];
  i_a_4[label="a,5"];

// 然后是他们之上的初始化的treenode
/*
<1>::=a
<3>::=a
<2>::=b
*/
  b_2_0[label="1,1,<2>,1"];
  b_2_0 -> i_b_0;

  a_1_1[label="2,2,<1>,1"];
  a_3_1[label="2,2,<3>,1"];
  a_1_1 -> i_a_1;
  a_3_1 -> i_a_1;

  a_1_2[label="3,3,<1>,1"];
  a_3_2[label="3,3,<3>,1"];
  a_1_2 -> i_a_2;
  a_3_2 -> i_a_2;

  b_2_3[label="4,4,<2>,1"];
  b_2_3 -> i_b_3;

  a_1_4[label="5,5,<1>,1"];
  a_3_4[label="5,5,<3>,1"];
  a_1_4 -> i_a_4;
  a_3_4 -> i_a_4;

// 好的，下面我们开始算法，我们先不区分区间之类，仅仅把所有关系生成出来？
// ------------- len = 2 -----------------
n21_0[label="1,2,<1>,1"]
n21_0 -> b_2_0
n21_0 -> a_1_1

n23_0[label="1,2,<0>,1"]
n23_0 -> b_2_0
n23_0 -> a_3_1

n12_0[label="3,4,<0>,1"]
n12_0 -> a_1_2
n12_0 -> b_2_3

n12_1[label="3,4,<3>,1"]
n12_1 -> a_1_2
n12_1 -> b_2_3

n21_1[label="4,5,<1>,1"]
n21_1 -> b_2_3
n21_1 -> a_1_4

// Note: 只有x,x,<x>相同的才会进行合并！我们继续计算！
// -------------- len = 3 ---------------
n33_0[label="3,5,<2>,1"]
n33_0 -> n12_1
n33_0 -> a_34

// -------------- len = 4 ---------------
n12_2[label="2,5,<3>,1"]
n12_2 -> a_1_1
n12_2 -> n33_0

// -------------- len = 5 ---------------
n23_1[label="1,5,<0>,1"]
n23_1 -> b_2_0
n23_1 -> n12_2

n12_4[label="1,5,<0>,1"]
n12_4 -> n21_0
n12_4 -> n33_0

n12_3[label="1,5,<3>,1"]
n12_3 -> n21_0
n12_3 -> n33_0

/*
<0>::=<1><2>
<0>::=<2><3>
<1>::=<2><1>
<2>::=<3><3>
<3>::=<1><2>
*/

subgraph c_0{
  rank=same;
  {rank=same; i_b_0; i_a_1; i_a_2; i_b_3; i_a_4;}
}

subgraph c_1{
  rank=same;
  {rank=same; b_2_0; a_1_1; a_3_1; a_1_2; a_3_2; b_2_3; a_1_4; a_3_4;}
}

subgraph c_2{
  rank=same;
  {rank=same; n21_0; n23_0; n12_0; n12_1; n21_1;}
}

subgraph c_3{
  rank=same;
  {rank=same; n33_0;}
}

subgraph c_4{
  rank=same;
  {rank=same; n12_2;}
}

subgraph c_5{
  rank=same;
  {rank=same; n23_1; n12_3; n12_4;}
}
}
